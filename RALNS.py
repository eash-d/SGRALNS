from copy import deepcopy
import numpy as np
import random
from vehicle import Car, sync_times_and_waypoints
from input_data import SG, orders_list
from router import euc
from initial_assign import is_time_in_range
from value_func import calc_slack_time, calc_extra_cost
import random

max_rwd = -0x3f3f3f3f
min_rwd = 0x3f3f3f3f

""" refer to our paper """

def roulette_wheel_selection(A):
    """ generated by chatgpt """
    total_weight = sum(A)
    r = random.uniform(0, total_weight)
    current_sum = 0
    for i, weight in enumerate(A):
        current_sum += weight
        if r <= current_sum:
            return i
    return random.randint(0, len(A)-1)
        
def degree_between_order_x_and_order_y(xidx, yidx):
    return float(SG[xidx,yidx] + SG[yidx,xidx])

def calc_sg_degree(order_idx_: int, orders_idx_list_: list, noise):
    dg = 0
    for idx in orders_idx_list_:
        dg += SG[order_idx_, idx] + SG[idx, order_idx_]
    return float(dg * noise)

def calc_regret(order_idx_, cars_list_, noise):
    """ regret_value """
    car: Car
    cars_insert_info_for_order_idx_tup = []        
    for car in cars_list_:
        if car.is_idle() == True:
            continue
        insert_cost, insert_orig_idx, insert_dest_idx = car.insert_to_car_based_value_function(orders_list[order_idx_], orders_list, calc_extra_cost)
        if insert_cost != 0x3f3f3f3f:
            cars_insert_info_for_order_idx_tup.append((insert_cost, car.id, insert_orig_idx, insert_dest_idx))
    if len(cars_insert_info_for_order_idx_tup) <= 1:
        return -1
    sorted_cars_insert_info_for_order_idx_tup = sorted(cars_insert_info_for_order_idx_tup, key=lambda tup: tup[0], reverse=False)
    regret_val = sorted_cars_insert_info_for_order_idx_tup[0][0] - sorted_cars_insert_info_for_order_idx_tup[1][0]
    return float(regret_val * noise)

def calc_greedy_cost(order_idx_, cars_list_, noise):
    car: Car
    greedy_cost = 0x3f3f3f3f
    for car in cars_list_:
        if car.is_idle() == True:
            continue
        insert_cost, insert_orig_idx, insert_dest_idx = car.insert_to_car_based_value_function(orders_list[order_idx_], orders_list, calc_extra_cost)
        greedy_cost = min(greedy_cost, insert_cost)
    return greedy_cost


class RALNS():
    def __init__(self, insert_operator_num, remove_operator_num, r_x, r_y, r_z, learning_rate) -> None:
        self.insert_op_weight = [10] * insert_operator_num
        self.remove_op_weight = [10] * remove_operator_num
        # self.remove_op_weight[0] = 11
        self.learning_rate = learning_rate
        self.r_x = r_x
        self.r_y = r_y
        self.r_z = r_z
    
    def get_removable_orders_idx(self, cars_list_):
        """ wpidx + r_x (包括) 之后的都能删除. 例如 wpidx + r_x = 2, 那么也就是说2以后(包括2)的乘客都可以删除  """
        removable_orders_idx = []
        car: Car
        for car in cars_list_:
            if car.over_highway() == True:
                continue
            
            # 要把停在车场的车做额外处理吗
            if car.wpidx == 0 and len(car.serving_list) != 0:
                removable_orders_idx += car.serving_list
                continue
            
            pivot_idx = car.wpidx + self.r_x
            if pivot_idx > len(car.waypoints) // 2:
                continue
            pivot_time = car.times[pivot_idx] + self.r_y
            for i in range(pivot_idx, len(car.waypoints) // 2 + 1):
                if car.times[i] <= pivot_time:
                    continue
                if car.waypoints[i] < 0: # type: ignore
                    raise Exception(f" !!! RALNS.py -> line 69")
                removable_orders_idx.append(car.waypoints[i])
        return removable_orders_idx

    def R_0(self, removable_orders_idx_):
        """ 共享度删除 """
        seed_order_idx = random.choice(removable_orders_idx_)
        orders_idx_with_seed_dg_pr = [(order_idx, degree_between_order_x_and_order_y(order_idx,seed_order_idx)) for order_idx in removable_orders_idx_]
        
        # sorted_orders_idx_with_seed_dg_pr = sorted(orders_idx_with_seed_dg_pr, key=lambda pr: pr[1], reverse=True)[:random.randint(1, max(1,int(len(removable_orders_idx_) * 0.5)))]
        
        # min_remove_number = max(1,int(len(removable_orders_idx_) * 0.5))
        # max_remove_number = len(removable_orders_idx_)
        min_remove_number = 1         
        max_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        # sorted_orders_idx_with_seed_dg_pr = sorted(orders_idx_with_seed_dg_pr, key=lambda pr: pr[1], reverse=True)[:random.randint(min_remove_number, max_remove_number)]        
        sorted_orders_idx_with_seed_dg_pr = sorted(orders_idx_with_seed_dg_pr, key=lambda pr: pr[1], reverse=True)[:max_remove_number]        
        
        # sorted_orders_idx_with_seed_dg_pr = sorted(orders_idx_with_seed_dg_pr, key=lambda pr: pr[1], reverse=True)
        # indices_to_remove = random.sample(range(len(sorted_orders_idx_with_seed_dg_pr)), random.randint(1, max(1,int(len(sorted_orders_idx_with_seed_dg_pr) * 0.5))))
        # indices_to_remove.sort(reverse=True)
        # for idx in indices_to_remove:
        #     del sorted_orders_idx_with_seed_dg_pr[idx]
        
        removed_orders_idx = [pr[0] for pr in sorted_orders_idx_with_seed_dg_pr]
        if seed_order_idx not in removed_orders_idx:
            removed_orders_idx.append(seed_order_idx)
        return removed_orders_idx
    def R_1(self, removable_orders_idx_):
        """ 随机删除 """
        # min_remove_number = 1         
        min_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        max_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        # removed_orders_idx = random.sample(removable_orders_idx_, random.randint(1, max(1,int(len(removable_orders_idx_) * 0.5))))
        removed_orders_idx = random.sample(removable_orders_idx_, random.randint(min_remove_number, max_remove_number))
        return removed_orders_idx
    
    
    # def R_2(self, removable_orders_idx_, cars_list_):
    #     """ 删除最绕路的 (绕路系数从大到小) """
    #     removable_orders_slktime = []
    #     car: Car
    #     for removable_order_idx in removable_orders_idx_:
    #         for car in cars_list_:
    #             if removable_order_idx not in car.waypoints:
    #                 continue
    #             o_time_idx = car.waypoints.index(removable_order_idx)
    #             d_time_idx = car.waypoints.index(-removable_order_idx)
    #             detour_coff = (car.times[d_time_idx] - car.times[o_time_idx]) / orders_list[removable_order_idx].o2d
    #             removable_orders_slktime.append(detour_coff)
    #             break
    #     if len(removable_orders_slktime) != len(removable_orders_idx_):
    #         print(f" >>> removable_orders_slktime: {removable_orders_slktime}")
    #         print(f" >>> removable_orders_idx_: {removable_orders_idx_}")
    #         raise Exception("NoOoOoOoOoOoO WayYyYyYy !!!")
    #     orders_idx_and_slktime_pr = [(removable_orders_idx_[i], removable_orders_slktime[i]) for i in range(len(removable_orders_idx_))]  

    #     # sorted_orders_idx_and_slktime_pr = sorted(orders_idx_and_slktime_pr, key=lambda pr: pr[1])[:random.randint(1, max(1,int(len(removable_orders_idx_) * 0.5)))]
    #     min_remove_number = 1                  
    #     max_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
    #     # sorted_orders_idx_and_slktime_pr = sorted(orders_idx_and_slktime_pr, key=lambda pr: pr[1])[:random.randint(min_remove_number, max_remove_number)]
    #     sorted_orders_idx_and_slktime_pr = sorted(orders_idx_and_slktime_pr, key=lambda pr: pr[1], reverse=True)[:max_remove_number]
        
    #     removed_orders_idx = [pr[0] for pr in sorted_orders_idx_and_slktime_pr]
    #     return removed_orders_idx
    
    def R_2(self, removable_orders_idx_, cars_list_):
        """ 删除slktime最小的 """
        removable_orders_slktime = []
        car: Car
        for removable_order_idx in removable_orders_idx_:
            for car in cars_list_:
                if removable_order_idx not in car.waypoints:
                    continue
                o_time_idx = car.waypoints.index(removable_order_idx)
                d_time_idx = car.waypoints.index(-removable_order_idx)
                removable_orders_slktime.append(min(orders_list[removable_order_idx].ddlo - car.times[o_time_idx], orders_list[removable_order_idx].ddld - car.times[d_time_idx]))
                break
        if len(removable_orders_slktime) != len(removable_orders_idx_):
            print(f" >>> removable_orders_slktime: {removable_orders_slktime}")
            print(f" >>> removable_orders_idx_: {removable_orders_idx_}")
            raise Exception("NoOoOoOoOoOoO WayYyYyYy !!!")
        orders_idx_and_slktime_pr = [(removable_orders_idx_[i], removable_orders_slktime[i]) for i in range(len(removable_orders_idx_))]  
        # sorted_orders_idx_and_slktime_pr = sorted(orders_idx_and_slktime_pr, key=lambda pr: pr[1])[:random.randint(1, max(1,int(len(removable_orders_idx_) * 0.5)))]
        min_remove_number = 1
        max_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        # sorted_orders_idx_and_slktime_pr = sorted(orders_idx_and_slktime_pr, key=lambda pr: pr[1])[:random.randint(min_remove_number, max_remove_number)]
        sorted_orders_idx_and_slktime_pr = sorted(orders_idx_and_slktime_pr, key=lambda pr: pr[1])[:max_remove_number]
        removed_orders_idx = [pr[0] for pr in sorted_orders_idx_and_slktime_pr]
        return removed_orders_idx
    
    # def R_3(self, removable_orders_idx_, cars_list_):
    #     """ 删除车上人最少的最大的 """
    #     sorted_cars_list = []
    #     removed_orders_idx = []

    #     for pr in sorted_cars_list:
    #         car = pr[0]
    #         waypoints_set = set(deepcopy(car.waypoints))
    #         # print(removable_orders_idx_)
    #         removable_orders_idx_set = set(deepcopy(removable_orders_idx_))
    #         uni = list(waypoints_set & removable_orders_idx_set) 
    #         if len(uni) == 0:
    #             continue
    #         for order_idx in uni:
    #             if len(removed_orders_idx) == int(len(removable_orders_idx_)*0.5):
    #                 return removed_orders_idx
    #             removed_orders_idx.append(order_idx)
    #     return removed_orders_idx
    
    def R_3(self, removable_orders_idx_, cars_list_):
        """ 删除 extra cost 最大的 (从大到小) """
        removable_orders_extra_cost = []
        for removable_order_idx in removable_orders_idx_:
            for car in cars_list_:
                if removable_order_idx not in car.waypoints:
                    continue
                new_waypoints = deepcopy(car.waypoints)
                new_times = deepcopy(car.times)
                o_time_idx = car.waypoints.index(removable_order_idx)
                d_time_idx = car.waypoints.index(-removable_order_idx)
                del new_waypoints[d_time_idx]
                del new_waypoints[o_time_idx]
                del new_times[d_time_idx]
                del new_times[o_time_idx]
                bl, new_times = sync_times_and_waypoints(new_waypoints, new_times, car.wpidx, orders_list)
                removable_orders_extra_cost.append(calc_extra_cost(new_waypoints, new_times, car.wpidx, orders_list, removable_order_idx))
                break
            
        if len(removable_orders_extra_cost) != len(removable_orders_idx_):
            print(f" >>> removable_orders_slktime: {removable_orders_extra_cost}")
            print(f" >>> removable_orders_idx_: {removable_orders_idx_}")
            raise Exception("NoOoOoOoOoOoO WayYyYyYy !!!")
        orders_idx_and_extracost_pr = [(removable_orders_idx_[i], removable_orders_extra_cost[i])  for i in range(len(removable_orders_idx_))]
        
        # sorted_orders_idx_and_extracost_pr = sorted(orders_idx_and_extracost_pr, key=lambda pr: pr[1], reverse=True)
                
        min_remove_number = 1         
        max_remove_number = max(1,int(len(removable_orders_idx_) * 0.4))
        # sorted_orders_idx_and_extracost_pr = sorted(orders_idx_and_extracost_pr, key=lambda pr: pr[1], reverse=True)[:random.randint(min_remove_number, max_remove_number)]
        sorted_orders_idx_and_extracost_pr = sorted(orders_idx_and_extracost_pr, key=lambda pr: pr[1], reverse=True)[:max_remove_number]
        
        # sorted_orders_idx_and_extracost_pr = sorted(orders_idx_and_extracost_pr, key=lambda pr: pr[1], reverse=True)
        # indices_to_remove = random.sample(range(len(sorted_orders_idx_and_extracost_pr)), random.randint(1, max(1,int(len(sorted_orders_idx_and_extracost_pr) * 0.5))))
        # indices_to_remove.sort(reverse=True)
        # for idx in indices_to_remove:
        #     del sorted_orders_idx_and_extracost_pr[idx]
        
        removed_orders_idx = [pr[0] for pr in sorted_orders_idx_and_extracost_pr]
        return removed_orders_idx
        
        
    
    def I_0(self, removed_orders_idx_, others_orders_list_):
        """ 共享度正序 """
        removed_orders_idx_pr = [(order_idx, calc_sg_degree(order_idx, others_orders_list_, 1)) for order_idx in removed_orders_idx_]
        sorted_removed_orders_idx_pr = sorted(removed_orders_idx_pr, key=lambda pr: pr[1], reverse=False)
        insert_orders_idx = [pr[0] for pr in sorted_removed_orders_idx_pr]
        return insert_orders_idx
    
    def I_1(self, removed_orders_idx_, others_orders_list_):
        """ 共享度倒序 """
        removed_orders_idx_pr = [(order_idx,  calc_sg_degree(order_idx, others_orders_list_, 1)) for order_idx in removed_orders_idx_]
        sorted_removed_orders_idx_pr = sorted(removed_orders_idx_pr, key=lambda pr: pr[1], reverse=True)
        insert_orders_idx = [pr[0] for pr in sorted_removed_orders_idx_pr]
        return insert_orders_idx
    
    def I_2(self, removed_orders_idx_, cars_list_):
        """ 遗憾值倒序 (从大到小越遗憾越先插入, 插入非空车) """
        removed_orders_idx_pr = [(order_idx, calc_regret(order_idx, cars_list_, 1)) for order_idx in removed_orders_idx_]
        sorted_removed_orders_idx_pr = sorted(removed_orders_idx_pr, key=lambda pr: pr[1], reverse=True)
        insert_orders_idx = [pr[0] for pr in sorted_removed_orders_idx_pr]
        return insert_orders_idx
    
    def I_3(self, removed_orders_idx_, cars_list_):
        """ 贪婪插入(最小额外成本, 插入非空车) """
        removed_orders_idx_pr = [(order_idx, calc_greedy_cost(order_idx, cars_list_, 1)) for order_idx in removed_orders_idx_]
        sorted_removed_orders_idx_pr = sorted(removed_orders_idx_pr, key=lambda pr: pr[1], reverse=False)
        insert_orders_idx = [pr[0] for pr in sorted_removed_orders_idx_pr]
        return insert_orders_idx
        
    def choose_insert_operator(self):
        return roulette_wheel_selection(self.insert_op_weight)
        
    def choose_remove_operator(self):
        return roulette_wheel_selection(self.remove_op_weight)

    def calc_obj_value(self, cars_list_):
        """ 奖励函数一定要符合: F 的值越大越好 """
        cnt = obj1 = obj2 = obj3 = obj4 = 0
        car: Car
        for car in cars_list_:
            if car.is_idle() == True:
                continue
            obj1 += len(car.serving_list)
            obj2 += car.times[-1] - car.times[0]
            cnt += 1
            obj3 += calc_slack_time(car.waypoints, car.times, car.wpidx, orders_list, -1)
        # print(f" >>> average slack time: {obj3/cnt}")
        # print(f" > test: {obj1/cnt}, {obj3/cnt}")
        # print(obj2/cnt*1)
        # print(obj1*100, obj2/cnt, cnt)
        # print(obj2/cnt, obj3/cnt, cnt)
        # print((- obj2 / cnt), (- obj3 / cnt * 10))
        # print("=-=-=-=-=-=-=-=-=-=-=-=")
        # F = obj1*1000 - obj2/cnt*1 - cnt*1    # 用这个看看重分配次数
        F = obj1*1000 - obj2/cnt*1 - cnt*50 # 用这个最雅目前
        # F = obj1*10000 + obj1/cnt*1000
        # F = obj1*100000 - obj2 - cnt*0 
        # F = obj1*1000 - obj3/cnt*10 - cnt*0
        # F = obj1*10000 + (- obj2 / cnt) + (- obj3 / cnt * 3)
        # F = obj1*1000 + (- obj3 / cnt * 10)
        # print(F, obj1*10000, (- obj3 / cnt * 10))
        # F = - obj2 / cnt
        # F = - obj3 / cnt
        return obj1, F
    
    def update_prob(self, old_obj_, new_obj_, R_id_1, R_id_2, I_id_):
        # print(f"> DEBUG > RALNS.py > diff: {new_obj_ - old_obj_}")
        global max_rwd, min_rwd
        
        if new_obj_ > old_obj_:
            max_rwd = max(max_rwd, np.log2(new_obj_ - old_obj_ + 1))
            min_rwd = min(min_rwd, np.log2(new_obj_ - old_obj_ + 1))
            # max_rwd = max(max_rwd, new_obj_ - old_obj_)
            # min_rwd = min(min_rwd, new_obj_ - old_obj_)
            # rwd = (new_obj_ - old_obj_) / 10
            rwd = np.log2(new_obj_ - old_obj_ + 1) / 10
            # print(rwd)
            self.remove_op_weight[R_id_1] = self.remove_op_weight[R_id_1] * self.learning_rate +  rwd / 2
            self.remove_op_weight[R_id_2] = self.remove_op_weight[R_id_2] * self.learning_rate + rwd / 2
            self.insert_op_weight[I_id_] = self.insert_op_weight[I_id_] * self.learning_rate + rwd
        elif new_obj_ == old_obj_:
            pass
        else:
            max_rwd = max(max_rwd, np.log2(old_obj_ - new_obj_ + 1))             
            min_rwd = min(min_rwd, np.log2(old_obj_ - new_obj_ + 1))
            # max_rwd = max(max_rwd, new_obj_ - old_obj_)
            # min_rwd = min(min_rwd, new_obj_ - old_obj_)
            # rwd = (old_obj_ - new_obj_) / 10
            rwd = np.log2(old_obj_ - new_obj_ + 1) / 10
            # self.remove_op_weight[R_id_1] -= rwd / 2
            # self.remove_op_weight[R_id_2] -= rwd / 2
            # self.insert_op_weight[I_id_] -= rwd
            # if self.remove_op_weight[R_id_1] < 1:
            #     self.remove_op_weight[R_id_1] += rwd / 2
            # if self.remove_op_weight[R_id_2] < 1:                                  
            #     self.remove_op_weight[R_id_2] += rwd / 2
            # if self.insert_op_weight[I_id_] < 1:
            #     self.insert_op_weight[I_id_] = rwd
            r1_bkup = self.remove_op_weight[R_id_1]
            r2_bkup = self.remove_op_weight[R_id_2]
            i_bkup = self.insert_op_weight[I_id_]
            
            self.remove_op_weight[R_id_1] = self.remove_op_weight[R_id_1] * self.learning_rate - rwd / 2
            self.remove_op_weight[R_id_2] = self.remove_op_weight[R_id_2] * self.learning_rate - rwd / 2
            self.insert_op_weight[I_id_] = self.insert_op_weight[I_id_] * self.learning_rate - rwd
            
            if self.remove_op_weight[R_id_1] < 1:
                self.remove_op_weight[R_id_1] = r1_bkup
            if self.remove_op_weight[R_id_2] < 1:                                  
                self.remove_op_weight[R_id_2] = r2_bkup
            if self.insert_op_weight[I_id_] < 1:
                self.insert_op_weight[I_id_] = i_bkup

""" TEST """
# ralns = RALNS(4,3,1,300,0.5,0.95)
# print(ralns.insert_op_prob)
# print(ralns.remove_op_prob)
# print(ralns.wheel_insert_op())
# print(ralns.wheel_insert_op()) 
# print(ralns.wheel_insert_op()) 

def get_min_max():
    global min_rwd, max_rwd
    
    print(f" >>> DEBUG: {min_rwd}, {max_rwd}")